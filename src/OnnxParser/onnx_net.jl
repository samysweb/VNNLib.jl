

"""
Type for ONNX computational graph.

Note that output names and node names are not the same in general,
as some nodes (e.g. LSTMs) can produce multiple outputs.

parameters:
- `start_nodes`: vector containing names of the starting nodes
- `final_nodes`: vector containing names of the final nodes
- `nodes`: dictionary mapping node names to `Node` objects
- `output_dict`: dictionary mapping output names to the name of the node that generates them
- `node_prevs`: dictionary mapping node names to vectors of names of parent nodes
- `node_nexts`: dictionary mapping node names to vectors of names of child nodes
- `input_shapes`: dictionary mapping input names to their input shapes
- `output_shapes`: dictionary mapping output names to their output shapes
"""
struct OnnxNet{S,N1,N2}
    start_nodes::Vector{S}
    final_nodes::Vector{S}
    nodes::Dict{S, Node{S}}
    output_dict::Dict{S, S}
    node_prevs::Dict{S, Vector{S}}
    node_nexts::Dict{S, Vector{S}}
    input_shapes::Dict{S, NTuple{N1,Int64}}
    output_shapes::Dict{S, NTuple{N2,Int64}}
end

get_input_names(net::OnnxNet) = collect(keys(net.input_shapes))
get_output_names(net::OnnxNet) = collect(keys(net.output_shapes))


function OnnxNet(nodes, start_nodes::VS, final_nodes::VS, input_shape_dict, output_shape_dict) where {S,VS<:AbstractVector{S}}
    # note that the output name and the node name are not the same in general!
    # some nodes (e.g. LSTMs) can produce multiple outputs
    node_dict = Dict{S, Node{S}}()
    node_prevs = Dict{S, Vector{S}}()
    node_nexts = Dict{S, Vector{S}}()

    # mapping from output name to name of node that generates it
    output_dict = Dict{S, S}()
    # mapping from output name to nodes that need it as input
    input_dict= Dict{S, Vector{S}}()

    for n in nodes
        if haskey(node_dict, n.name)
            throw(ArgumentError("Duplicate node name found: $(n.name)"))
        end

        node_dict[n.name] = n

        for o in n.outputs
            @assert !haskey(output_dict, o) "An output cannot be generated by multiple nodes! Duplicate output name found: $o"
            output_dict[o] = n.name
        end

        for i in n.inputs
            if !haskey(input_dict, i)
                input_dict[i] = []
            end
            push!(input_dict[i], n.name)
        end
    end

    for n in nodes
        node_prevs[n.name] = [output_dict[i] for i in n.inputs if haskey(output_dict, i)]
        node_nexts[n.name] = reduce(vcat, [input_dict[o] for o in n.outputs if haskey(input_dict, o)], init=Vector{S}())
    end

    # sometimes shape info contains strings like "batch"
    for (k, v) in input_shape_dict
        input_shape = map(s -> ifelse(typeof(s) <: Integer, s, 1), v)
        input_shape_dict[k] = input_shape
    end
    for (k, v) in output_shape_dict
        output_shape = map(s -> ifelse(typeof(s) <: Integer, s, 1), v)
        output_shape_dict[k] = output_shape
    end

    OnnxNet(start_nodes, final_nodes, node_dict, output_dict, node_prevs, node_nexts, input_shape_dict, output_shape_dict)
end



function NNL.construct_network(::Type{OnnxType}, inputs, outputs, nodes, input_shape_dict, output_shape_dict)
    if VERBOSE_ONNX[] > 0
        println("Constructing ONNX network with\n\tinputs: $(input_shape_dict)\n\toutputs: $(output_shape_dict)")
    end

    input_nodes = []
    output_nodes = []
    for (k, v) in nodes
        # the inputs are the names of the input arguments, not the node names,
        # so we need to check if the node's inputs only consist of input parameters 
        if issubset(v.inputs, inputs)
            push!(input_nodes, k)
        end

        # the outputs are the names of the output arguments, not the node names,
        # so we need to check if the node's outputs contain one of the output parameters
        if any(in(outputs), v.outputs)
            push!(output_nodes, k)
        end
    end

    # need to change from NCHW to WHCN
    # extract and repackage in dict to avoid type issues
    ks = keys(input_shape_dict)
    input_shapes = [reverse(tuple(input_shape_dict[k]...)) for k in ks]
    input_shape_dict = Dict(ks .=> input_shapes)

    ks = keys(output_shape_dict)
    output_shapes = [reverse(tuple(output_shape_dict[k]...)) for k in ks]
    output_shape_dict = Dict(ks .=> output_shapes)

    OnnxNet([n for n in values(nodes)], [n for n in input_nodes], [n for n in output_nodes], input_shape_dict, output_shape_dict)
    #return nodes, input_nodes, output_nodes, input_shape, output_shape
end


"""
Collects the inputs a node needs to compute its output for the output dict of the previously seen nodes.

args:
- `net`: the ONNX network
- `node_name`: the name of the node for which to collect inputs
- `out_dict`: the dictionary mapping output names to their values
"""
function collect_inputs(net::OnnxNet{S,N1,N2}, node_name::S, out_dict::Dict{S,AN}) where {S,N1,N2,AN}
    [out_dict[i] for i in net.nodes[node_name].inputs]
end


"""
Adds the outputs of a node to the output dictionary.

args:
- `net`: the ONNX network
- `node_name`: the name of the node for which to add outputs
- `out_dict`: the dictionary mapping output names to their values
- `outputs`: the outputs of the node, which are computed by the Flux layer
"""
function add_outputs!(net::OnnxNet{S,N1,N2}, node_name::S, out_dict::Dict{S,AN}, outputs) where {S,N1,N2,AN}
    out_names = net.nodes[node_name].outputs
    # need this distinction as otherwise, we might try to zip output arrays with single output names and then 
    # just add single floats to the dictionary
    if length(out_names) == 1
        out_dict[out_names[1]] = outputs
    else
        for (o, on) in zip(outputs, out_names)
            out_dict[on] = o
        end
    end
end



"""
Computes all outputs (including intermediate outputs) of the ONNX network for the given input dictionary.

args:
- `net`: the ONNX network
- `x_dict`: dictionary mapping input names to their values

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: dictionary mapping output names to their values
"""
function compute_all_outputs(net::OnnxNet{S,N1,N2}, x_dict::Dict{S,<:AbstractArray}; verbosity=0) where {S,N1,N2}
    # dictionary mapping output names (not node names!) to their values
    output_data = Dict{S,AbstractArray}()

    node_names = collect(keys(net.nodes))
    visit_cnt = Dict(node_names .=> 0)

    # map input names to their values, s.t. later nodes can access them
    for (k, v) in x_dict
        output_data[k] = v
    end

    queue = Queue{S}()
    for node_name in net.start_nodes
        enqueue!(queue, node_name)
    end

    
    while !isempty(queue)
        node_name = dequeue!(queue)
        node = net.nodes[node_name]

        verbosity > 0 && println("Processing node: $node_name")

        # at this point, we know that all parents of the current node have been visited
        # so all necessary inputs are available
        inputs = collect_inputs(net, node_name, output_data)
        outputs = onnx_node_to_flux_layer(node)(inputs...)

        verbosity > 1 && println("\tinputs: $inputs")
        verbosity > 1 && println("\toutputs: $outputs")
        verbosity > 1 && println("\toutput sizes: ", get_dims(outputs)) #[size(i) for i in outputs])

        add_outputs!(net, node_name, output_data, outputs)


        if !haskey(net.node_nexts, node_name)
            # this node has no children, so we can skip it
            verbosity > 0 && println("\tNo children, skipping")
            continue
        end

        for out_node in net.node_nexts[node_name]
            visit_cnt[out_node] += 1

            if visit_cnt[out_node] == length(net.node_prevs[out_node])
                # all parents of the output node have been visited, so we can process it
                enqueue!(queue, out_node)
            end
        end
    end

    output_data
end


"""
Computes all outputs (including intermediate outputs) of the ONNX network for the single input array.

args:
- `net`: the ONNX network
- `x`: the input array

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: dictionary mapping output names to their values
"""
function compute_all_outputs(net::OnnxNet{S,N1,N2}, x::AbstractArray; verbosity=0) where {S,N1,N2}
    input_names = get_input_names(net)

    @assert length(input_names) == 1 "Expected exactly one input name, got $(input_names)\nWrap inputs in a dictionary with the input name as key if you want multiple inputs."

    x_dict = Dict{S,AbstractArray}()
    x_dict[input_names[1]] = x
    compute_all_outputs(net, x_dict; verbosity=verbosity)
end


"""
Computes the outputs of the ONNX network for the given input dictionary.

No intermediate outputs are returned, only the final outputs.

args:
- `net`: the ONNX network
- `x_dict`: dictionary mapping input names to their values

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: dictionary mapping output names to their values
"""
function compute_outputs(net::OnnxNet{S,N1,N2}, x_dict::Dict{S,<:AbstractArray}; verbosity=0) where {S,N1,N2}
    # compute all outputs, but only return the one we are interested in
    output_data = compute_all_outputs(net, x_dict; verbosity=verbosity)
    output_names = get_output_names(net)
    Dict(output_names .=> [output_data[o] for o in output_names])
end


"""
Computes the outputs of the ONNX network for the single input array.

No intermediate outputs are returned, only the final outputs.

args:
- `net`: the ONNX network
- `x`: the input array

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: dictionary mapping output names to their values
"""
function compute_outputs(net::OnnxNet{S,N1,N2}, x::AbstractArray; verbosity=0) where {S,N1,N2}
    # compute all outputs, but only return the one we are interested in
    output_data = compute_all_outputs(net, x; verbosity=verbosity)
    output_names = get_output_names(net)
    Dict(output_names .=> [output_data[o] for o in output_names])
end


"""
Computes the single output of the ONNX network for the given input dictionary.

No intermediate outputs are returned, only the final output.

args:
- `net`: the ONNX network
- `x_dict`: dictionary mapping input names to their values

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: the final output of the network
"""
function compute_output(net::OnnxNet{S,N1,N2}, x_dict::Dict{S,<:AbstractArray}; verbosity=0) where {S,N1,N2}
    output_names = get_output_names(net)
    @assert length(output_names) == 1 "Expected exactly one output name, got $(output_names)\nDid you mean to call compute_output**s**?"
    output_data = compute_all_outputs(net, x_dict; verbosity=verbosity)
    output_data[output_names[1]]
end

"""
Computes the single output of the ONNX network for the single input array.

No intermediate outputs are returned, only the final output.

args:
- `net`: the ONNX network
- `x`: the input array

kwargs:
- `verbosity`: verbosity level (0 = no output, 1 = basic output, 2 = detailed output)

returns:
- `output_data`: the final output of the network
"""
function compute_output(net::OnnxNet{S,N1,N2}, x::AbstractArray; verbosity=0) where {S,N1,N2}
    output_names = get_output_names(net)
    @assert length(output_names) == 1 "Expected exactly one output name, got $(output_names)\nDid you mean to call compute_output**s**?"
    output_data = compute_all_outputs(net, x; verbosity=verbosity)
    output_data[output_names[1]]
end